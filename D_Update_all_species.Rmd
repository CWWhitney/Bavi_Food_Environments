## Create `bayesian_update_function`

Create a function for Bayesian updating with `purrr`, `fs` and `stringr`

```{r bayesian_update_function}
source("functions/bayesian_update.R")
```

Define directories

```{r define_directories}
# Define directories
species_dir <- "data"
updated_dir <- "data/updated"

# Ensure updated directory exists
dir_create("data/updated")
```

Also assign a base directory for the updated data

```{r name_base_directory}
# Ensure base directory
base_dir <- "data/updated"
```

List all the files that are in the `base_dir` in the new `updated_species_files`

```{r updated_species_files}
# Get all updated files
updated_species_files <- list.files(base_dir, pattern = "\\.R$", full.names = TRUE)
```

## Get all `unique_species` 

Trim away trailing and leading spaces with `trimws`

```{r unique_species}
# Get all unique species
unique_species <- unique(trimws(data$scientific_name_snake_case))  # Trim spaces
```

## Create `process_species` 

The update to the data is based on observations in the field and these were responses that need numeric interpretation. Here is how the interpretation went. 

```{r, echo=FALSE, message=FALSE}
library(knitr)

# Create the table
table_data <- data.frame(
  State = c("Rare Species", "Common Species", "Destructive Harvest", "High Nutrition", 
            "Low Nutrition", "Many Users", "Few Users"),
  Effect_Change = c("+0.05 to +0.1", "-0.05 to -0.1", "-0.05", "+0.05", 
                    "-0.05", "-0.05", "-0.05"),
  SD_Change = c("Decrease (more certainty)", "Increase (more uncertainty)", "+0.005", 
                "Decrease", "Increase", "Decrease", "Increase"),
  Interpretation = c(
    "Conservation actions are more effective with rare species, leading to a greater positive effect. Less uncertainty because of urgency and targeted efforts.",
    "Conservation efforts have less impact on common species, leading to a reduced effect. Higher uncertainty due to broader variability in population responses.",
    "Overharvesting reduces conservation effectiveness. Increased uncertainty due to varied management responses.",
    "Higher nutrition leads to stronger dietary diversity improvements. More certainty due to known nutritional benefits.",
    "Poor nutrition contributes less to dietary diversity. Greater uncertainty due to variability in dietary adoption.",
    "High user numbers reduce the individual impact of knowledge sharing. More certainty in effect estimates due to larger adoption.",
    "Low adoption reduces knowledge-sharing impact. Increased uncertainty due to variability in individual responses."
  )
)

# Print the table
kable(table_data, format = "markdown", col.names = c("State", "Effect Change", "SD Change", "Interpretation"))
```

Create updated data for the assessment of management options for food environments and conservation. 

```{r process_species}

# Function to process each species
# Effect constraints (-1 to 1)
process_species <- function(species_name) {
  
  # Construct file paths
  species_filename <- str_c("effects_sd_map_", species_name, ".R")
  species_filepath <- file.path(species_dir, species_filename)
  updated_filename <- species_filename  # Keep the same filename
  updated_filepath <- file.path(updated_dir, updated_filename)
  
  # Check if file exists
  if (!file.exists(species_filepath)) {
    message("File not found for: ", species_name)
    return(NULL)
  }
  
  message("Sourcing R script: ", species_filepath)
  
  # Source the R script to load the effect data
  source(species_filepath, local = TRUE)
  
  # Identify the loaded variable dynamically
  loaded_objects <- ls(pattern = "effects_sd_map_")
  
  if (length(loaded_objects) == 0) {
    message("No object found in: ", species_filename)
    return(NULL)
  }
  
  # Extract the loaded object dynamically
  effects_data <- get(loaded_objects[1])
  
  # Define prior knowledge-based parameters to update
  rare_species <- any(data$scientific_name_snake_case == species_name & data$current_reserves %in% c("Few", "Not many"))
  common_species <- any(data$scientific_name_snake_case == species_name & data$current_reserves == "Many")
  destructive_harvest <- any(data$scientific_name_snake_case == species_name & data$parts_used == "destructive")
  high_nutrition <- any(data$scientific_name_snake_case == species_name & data$nutritional_value == "High")
  low_nutrition <- any(data$scientific_name_snake_case == species_name & data$nutritional_value == "Low")
  high_number_of_users <- any(data$scientific_name_snake_case == species_name & data$number_of_users == "Many")
  few_users <- any(data$scientific_name_snake_case == species_name & data$number_of_users == "Few")
  
  # Adjust SpeciesConservation & SustainableFoodEnv for rare species
  if (rare_species) {
  effects_data$SpeciesConservation$control_access$Effect <- min(1, effects_data$SpeciesConservation$control_access$Effect + 0.1)
  effects_data$SpeciesConservation$control_access$SD <- max(0.01, effects_data$SpeciesConservation$control_access$SD - 0.01)
  
  effects_data$SpeciesConservation$provide_seedlings$Effect <- min(1, effects_data$SpeciesConservation$provide_seedlings$Effect + 0.15)
  effects_data$SpeciesConservation$provide_seedlings$SD <- max(0.01, effects_data$SpeciesConservation$provide_seedlings$SD - 0.01)
}
  
  # Adjust SpeciesConservation & SustainableFoodEnv for common species
if (common_species) {
  effects_data$SpeciesConservation$control_access$Effect <- max(-1, effects_data$SpeciesConservation$control_access$Effect - 0.1)
  effects_data$SpeciesConservation$control_access$SD <- min(0.2, effects_data$SpeciesConservation$control_access$SD + 0.01)
  
  effects_data$SpeciesConservation$provide_seedlings$Effect <- max(-1, effects_data$SpeciesConservation$provide_seedlings$Effect - 0.15)
  effects_data$SpeciesConservation$provide_seedlings$SD <- min(0.2, effects_data$SpeciesConservation$provide_seedlings$SD + 0.01)
}
  
  # Adjust for destructive harvesting
  if (destructive_harvest) {
  effects_data$SpeciesConservation$control_access$Effect <- max(-1, effects_data$SpeciesConservation$control_access$Effect - 0.05)
  effects_data$SpeciesConservation$control_access$SD <- min(0.2, effects_data$SpeciesConservation$control_access$SD + 0.005)

  effects_data$SpeciesConservation$provide_access_control_harvest$Effect <- max(-1, effects_data$SpeciesConservation$provide_access_control_harvest$Effect - 0.05)
  effects_data$SpeciesConservation$provide_access_control_harvest$SD <- min(0.2, effects_data$SpeciesConservation$provide_access_control_harvest$SD + 0.005)

  effects_data$SpeciesConservation$allow_access_forest_parts$Effect <- max(-1, effects_data$SpeciesConservation$allow_access_forest_parts$Effect - 0.05)
  effects_data$SpeciesConservation$allow_access_forest_parts$SD <- min(0.2, effects_data$SpeciesConservation$allow_access_forest_parts$SD + 0.005)

  effects_data$SpeciesConservation$allow_access_limited_time$Effect <- max(-1, effects_data$SpeciesConservation$allow_access_limited_time$Effect - 0.05)
  effects_data$SpeciesConservation$allow_access_limited_time$SD <- min(0.2, effects_data$SpeciesConservation$allow_access_limited_time$SD + 0.005)
}
  
  # Adjust for high/low nutrition
if (high_nutrition) {
  effects_data$DietaryDiversity$Effect <- min(1, effects_data$DietaryDiversity$Effect + 0.05)
  effects_data$DietaryDiversity$SD <- max(0.01, effects_data$DietaryDiversity$SD - 0.005)
}

if (low_nutrition) {
  effects_data$DietaryDiversity$Effect <- max(-1, effects_data$DietaryDiversity$Effect - 0.05)
  effects_data$DietaryDiversity$SD <- min(0.2, effects_data$DietaryDiversity$SD + 0.005)
}
  
  # Adjust for high/few users
  if (high_number_of_users) {
    effects_data$TraditionalKnowledge$control_access$Effect <- effects_data$TraditionalKnowledge$control_access$Effect - 0.05
    effects_data$TraditionalKnowledge$control_access$SD <- max(0.001, effects_data$TraditionalKnowledge$control_access$SD - 0.005)
  }
  
  if (few_users) {
    effects_data$DietaryDiversity <- map(effects_data$DietaryDiversity, ~{
      list(Effect = .x$Effect - 0.05, SD = min(0.1, .x$SD + 0.005))
    })
  }
  
  # Save updated data as an R script
  dump(loaded_objects[1], file = updated_filepath)
  
  message("Updated and saved: ", updated_filename)
}

```

```{r create_species_names_for_updated_species_files}
# Extract species names by removing prefix and suffix
species_names <- sub("data/updated/effects_sd_map_(.*)\\.R", "\\1", updated_species_files)

```
Convert `species_names` to a named list

```{r updated_species_files_named}
# Convert to a named list
updated_species_files_named <- setNames(updated_species_files, species_names)

```

Use `walk` function from `purrr` to apply unique species names and `process_species` to all species in the data. 

```{r walk_unique_species_process_species}

# Apply function to all species
walk(names(updated_species_files_named), process_species)

```

### Plot an aggregated plot with `aggregate_species_data`

Plot generate aggregated data for all species in `updated_species_files_named` with `aggregate_species_data`

```{r aggregate_species_data_updated}
### Plot an aggregated plot with `aggregate_species_data`

source("functions/aggregate_species_data.R")
# Aggregate data across all species
aggregated_data <- aggregate_species_data(updated_species_files_named)

# Summarize aggregated data
summary_data <- aggregated_data %>%
  group_by(Decision, Outcome) %>%
  summarize(
    MeanEffect = mean(Effect, na.rm = TRUE),
    MeanSD = mean(SD, na.rm = TRUE),
    .groups = "drop"
  )

```

Apply `plot_aggregate_effects` to show the updated expectations across all the species in the study. 

```{r plot_aggregate_effects_update}
library(ggplot2)
source("functions/plot_aggregate_effects.R")
# Plot the data
plot_aggregate_effects(summary_data)

```
