---
title: "Forest access for sustainable food environments in Bavi"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(reshape2)
library(tidyverse)
```

Here we use Monte Carlo simulations based on expert knowledge. This is a well-established and flexible method for decision modeling. Allowing for use of expert-derived probabilities and variances to estimate outcomes, even when data is sparse. Capture the variability and uncertainty in model inputs. Guide decision-making by identifying likely outcomes and their variability.

## Generalized Function 

The function simulates outcomes for decision options. The `simulate_outcomes_for_decisions` function is a Monte Carlo simulation framework designed to evaluate multiple decision options against predefined outcomes, incorporating stochastic variability (variability_list) to reflect real-world uncertainties. This function is intended for use in scenarios where decisions have probabilistic impacts on outcomes, such as ecological management, conservation planning, or policy evaluation. Source the  `simulate_outcomes_for_decisions` function with `source`.

```{r source}
source("functions/simulate_outcomes_for_decisions.R")
```

### Function Purpose

The function calculates the expected outcomes for a series of decision options under uncertainty. Each decision option is evaluated against a set of outcomes using a weighted linear model, with added random variability_list to account for variability. The outputs are stored in a structured format for further analysis.

Function Inputs include: 

`decision_options`, a list where each element is a named vector representing a specific decision option. Each vector contains binary values (1 or 0), indicating whether a particular decision variable is active or inactive. For example: `control_access = c(1, 0, 0, 0, 0)` indicates that `control_access` is the first option in the list of decision options. 

`outcome_effects`, a matrix where rows represent outcomes (e.g., conservation success, financial cost). The columns correspond to decision variables. The elements specify the weight or influence of a decision variable on a given outcome. i.e. `matrix(c(0.8, 0.6, 0.5, 0.6, 0.7),nrow = 1)` for eh species Conservation outcome_effects corresponding to the columns of `decision_options`. 

The `variability_list` is a named list of functions, with each function generating random noise specific to a specific outcome. This allows for custom noise distributions to reflect expert knowledge or empirical data on variability. i.e. `list(SpeciesConservation = function(n) rnorm(n, mean = 0, sd = 0.05))` is a function assigning the noise to the interaction between species conservation and the decision options. 

`n_simulations` is the number of Monte Carlo iterations to perform for each combination of decision and outcome. 

The function returns `results` as a nested list with: Decision options (e.g., `control_access`). Outcome names (e.g., `SpeciesConservation`). Values: A vector of simulated outcome values for each combination of decision and outcome.

## Simulation Workflow

Decision Options:

The function iterates over each decision option in `decision_options`. For each decision option, the function calculates all outcomes defined in the `outcome_effects` matrix. Outcomes are calculated as a weighted sum of decision variables (defined by the `outcome_effects` matrix) plus a random variability_list term. `variability_list` is generated, allowing for outcome-specific variability. Results are stored in a nested list, enabling easy access for further analysis.

Example Use Case

For a conservation project, this function will be used to simulate the effects of different park management strategies (e.g., restricting access, providing seedlings) on:

- Species conservation: Probability of preserving species.
- Dietary diversity: Impact on local food systems.
- Expenditure: Financial cost to the park service.
- Cultural heritage: Loss of traditional knowledge.

By comparing the simulated outcomes for each strategy, decision-makers can identify trade-offs and prioritize actions. The function can handle multiple decision options and outcomes with ease. It incorporates expert-defined variability_list distributions for outcome variability. It also explicitly separates decision logic, outcome effects, and variability_list, ensuring clarity and reproducibility. For each decision option and outcome, the function calculates the **Outcome Value** using the following formula:

\[
\text{Outcome Value} = \sum_{i=1}^{n} \text{Decision}_i \times \text{Weight}_i + \text{variability_list}
\]

Where:

- \(\text{Decision}_i\): A binary value (\(1\) or \(0\)) indicating if the \(i\)-th decision is active.
- \(\text{Weight}_i\): The influence of the \(i\)-th decision variable on the outcome.
- \(\text{variability_list}\): A random term representing variability or uncertainty, specific to the outcome and decision, as defined by the `variability_list`.

```{r forest_access_graph}
# Load necessary libraries
library(DiagrammeR)
library(DiagrammeRsvg)
library(rsvg)

# Create the updated graph
forest_access_graph <- grViz("
  digraph forest_access_model {
    graph [layout = dot, rankdir = LR]

    // Define node styles
    node [shape = box, fontname = Helvetica]

    // Define nodes
    ControlAccess [label = 'Control Access']
    ProvideAccessControlHarvest [label = 'Provide Access + Control Harvest']
    AllowAccessForestParts [label = 'Allow Access to Forest Parts']
    AllowAccessLimitedTime [label = 'Allow Access for Limited Time']
    ProvideSeedlings [label = 'Provide Seedlings']

    SpeciesConservation [label = 'Species Conservation']
    DietaryDiversity [label = 'Dietary Diversity']
    SustainableFoodEnv [label = 'Sustainable Food Environment']
    ParkExpenditure [label = 'Park Expenditure']
    TraditionalKnowledge [label = 'Traditional Knowledge']

    // Define relationships between nodes
    ControlAccess -> {SpeciesConservation DietaryDiversity SustainableFoodEnv ParkExpenditure TraditionalKnowledge}
    ProvideAccessControlHarvest -> {SpeciesConservation DietaryDiversity SustainableFoodEnv ParkExpenditure TraditionalKnowledge}
    AllowAccessForestParts -> {SpeciesConservation DietaryDiversity SustainableFoodEnv ParkExpenditure TraditionalKnowledge}
    AllowAccessLimitedTime -> {SpeciesConservation DietaryDiversity SustainableFoodEnv ParkExpenditure TraditionalKnowledge}
    ProvideSeedlings -> {SpeciesConservation DietaryDiversity SustainableFoodEnv ParkExpenditure TraditionalKnowledge}
  }
")

forest_access_graph
```

# Decision model 

Create a `decision_options` vector with all the decision options for the park and communities surrounding the park. 

```{r decision_options_list}
# Define all decision options (each as a named vector)
decision_options_list <- list(
  control_access = c(1, 0, 0, 0, 0),
  provide_access_control_harvest = c(0, 1, 0, 0, 0),
  allow_access_forest_parts = c(0, 0, 1, 0, 0),
  allow_access_limited_time = c(0, 0, 0, 1, 0),
  provide_seedlings = c(0, 0, 0, 0, 1)
)
```

Define `outcome_effects` matrix for outcomes for decisions and outcomes.

```{r outcome_effects}
# outcome_effects (rows: outcomes, cols: decisions)
outcome_effects <- matrix(
  c(
    #control_access, provide_access_control_harvest, allow_access_forest_parts, allow_access_limited_time, provide_seedlings
    # Species Conservation outcome_effects
    0.8, 0.6, 0.5, 0.6, 0.7,
    # Dietary Diversity outcome_effects
    -0.6, 0.5, 0.6, 0.6, 0.7,
    # Sustainable Food Environment outcome_effects
    -0.4, 0.6, 0.7, 0.8, 0.9,
    # Park Expenditure outcome_effects
    0.9, 0.4, 0.3, 0.3, 0.8,
    # Traditional Knowledge outcome_effects
    -0.9, 0.7, 0.6, 0.5, 0.4
  ),
  nrow = 5, byrow = TRUE,
  dimnames = list(
    c("SpeciesConservation", "DietaryDiversity", "SustainableFoodEnv", "ParkExpenditure", "TraditionalKnowledge"),
    c("control_access", "provide_access_control_harvest", "allow_access_forest_parts", "allow_access_limited_time", "provide_seedlings")
  )
)
```

# Define a `variability_list` for each outcome.

```{r variability_list}
variability_list <- list(
  SpeciesConservation = function(n) 
    rnorm(n, mean = 0, sd = 0.05),  # Low uncertainty
  DietaryDiversity = function(n) 
    rnorm(n, mean = 0, sd = 0.1),     # Moderate uncertainty
  SustainableFoodEnv = function(n) 
    rnorm(n, mean = 0, sd = 0.08),  # Moderate uncertainty
  ParkExpenditure = function(n) 
    rnorm(n, mean = 0, sd = 0.2),      # High uncertainty
  TraditionalKnowledge = function(n) 
    rnorm(n, mean = 0, sd = 0.15)  # Moderate-high uncertainty
)
```

Run the simulation with the `variability_list`. 

```{r results}
results <- simulate_outcomes_for_decisions(decision_options_list, outcome_effects, variability_list)
```

```{r control_conservation}
# Example: Access results for a specific decision and outcome
head(results$control_access$SpeciesConservation)  # "Control Access" and "Species Conservation"
```

```{r seedlings_diets}
# Example: Access results for a different decision and outcome
head(results$provide_seedlings$DietaryDiversity)  # "Provide Seedlings" and "Dietary Diversity"
```

Add species with simplified input

```{r species_params}
source("functions/add_species_data.R")
```

The `Effect` represents the magnitude and direction of influence that a specific decision option has on an outcome for a given species. Positive values indicate a beneficial effect and nagative values visa versa. For instance, a value of 0.8 for `control_access` on `Species Conservation` implies a strong positive effect, whereas -0.2 for `provide_seedlings` on `Dietary Diversity` indicates a slight reduction in dietary diversity. A value of 0 means no effect. 

The SD (also `Variability_SD`) quantifies the uncertainty or variability in the effect values. A smaller SD (e.g., 0.05) indicates high confidence in `Effect`, suggesting that the impact is consistent across scenarios. Larger SD (e.g., 0.2) reflects greater uncertainty, for example, an SD of 0.05 for `control_access` on `Species Conservation` indicates low variability and high confidence, whereas an SD of 0.15 for `provide_seedlings` on `Dietary Diversity` denotes moderate uncertainty. 

```{r add_species_data}
source("functions/add_species_data.R")

# Initialize an empty dataset
species_data <- data.frame()

# Define decision options and outcomes
decision_options <- c("control_access", "provide_access_control_harvest", 
                      "allow_access_forest_parts", "allow_access_limited_time", "provide_seedlings")
outcomes <- c("SpeciesConservation", "DietaryDiversity", "SustainableFoodEnv", 
              "ParkExpenditure", "TraditionalKnowledge")

# List of species and their corresponding `.R` files
species_files <- list(
  bidens_pilosa = "data/effects_sd_map_bidens_pilosa.R",               
  # Bidens pilosa
  amomum_villosum = "data/effects_sd_map_amomum_villosum.R",           
  # Amomum villosum
  begonia = "data/effects_sd_map_begonia.R",                 
  # Begonia
  bischofia_javanica = "data/effects_sd_map_bischofia_javanica.R",    
  # Bischofia javanica Blum
  cheilocostus_speciosus = "data/effects_sd_map_cheilocostus_speciosus.R", 
  # Cheilocostus speciosus
  cyclosorus_acuminatus = "data/effects_sd_map_cyclosorus_acuminatus.R",
  # Cyclosorus acuminatus (Houtt)
  erythropalum_scandens = "data/effects_sd_map_erythropalum_scandens.R", 
  # Erythropalum scandens Blume
  ficus_auriculata = "data/effects_sd_map_ficus_auriculata.R", 
  # Ficus auriculata
  ficus_callosa = "data/effects_sd_map_ficus_callosa.R",     
  # Ficus callosa Willd.
  gynura_procumbens = "data/effects_sd_map_gynura_procumbens.R",        
  # Gynura procumbens (Lour.)
  melientha_suavis = "data/effects_sd_map_melientha_suavis.R",      
  # Melientha suavis
  musa_brachycarpa = "data/effects_sd_map_musa_brachycarpa.R",           
  # Musa brachycarpa Back
  ophiopogon_reptans = "data/effects_sd_map_ophiopogon_reptans.R",   
  # Ophiopogon reptans
  rubus_cochinchinensis = "data/effects_sd_map_rubus_cochinchinensis.R",     
  # Rubus cochinchinensis
  saurauia_tristyla = "data/effects_sd_map_saurauia_tristyla.R",      
  # Saurauia tristyla DC.
  schefflera_heptaphylla = "data/effects_sd_map_schefflera_heptaphylla.R", 
  # Schefflera heptaphylla
  sterculia_foetida = "data/effects_sd_map_sterculia_foetida.R",     
  # Sterculia foetida L.
  tetrapanax_papyriferus = "data/effects_sd_map_tetrapanax_papyriferus.R", 
  # Tetrapanax papyriferus
  tradescantia_pallida = "data/effects_sd_map_tradescantia_pallida.R" 
  # Tradescantia pallida
)

# Loop through species and add their data
for (species in names(species_files)) {
  species_data <- add_species_data(
    existing_data = species_data,
    species_name = species,
    decision_options = decision_options,
    outcomes = outcomes,
    species_file_path = species_files[[species]]
  )
}

```

Check the updated data for the species:
```{r check_sp_data}
head(species_data)
```

Load the built data and change format (for reading)
```{r load_built_data}
species_params <- as.data.frame(species_data)
#change to numeric
species_params$Effect <- as.numeric(species_params$Effect)
species_params$Variability_SD <- as.numeric(species_params$Variability_SD)
```

Clean the species level data (update botanical names). 

```{r tolower}
species_params$Species <- tolower(trimws(species_params$Species))
```

Construct the species_data object for each species based on `species_params`.

```{r}
source("functions/generate_species_data.R")
species_data <- generate_species_data(species_params)
```

Check for outcome effects

```{r outcome_effects-bidens_pilosa}
species_data$bidens_pilosa$outcome_effects
```

Test with 5 random noise values for the `SpeciesConservation` outcome, based on the standard deviation (sd) defined in `species_params`.

```{r SpeciesConservation_5}
# Test the Variability Function
species_data$bidens_pilosa$variability_list$SpeciesConservation(5)
```

Use the simulate_outcomes_for_decisions function with the processed data for `species_a` to simulate outcomes.

```{r simulations_bidens_pilosa}
source("functions/simulate_outcomes_for_decisions.R")
simulations_bidens_pilosa <- simulate_outcomes_for_decisions(
  decision_options = decision_options_list, #defined above
  outcome_effects = species_data$bidens_pilosa$outcome_effects,
  variability_list = species_data$bidens_pilosa$variability_list
)
```

We also reverse the expenses, since higher expenses are worse, they should appear as a negative result in the plot. 

```{r data_mgmt}
# Prepare the data
source("functions/prepare_heatmap_data.R")
heatmap_data <- prepare_heatmap_data(simulations_bidens_pilosa)

# Flatten simulations_b_pilosa into a data frame
source("functions/flatten_results.R")
# Flatten simulations_b_pilosa
heatmap_data <- flatten_results(simulations_bidens_pilosa, species_data$bidens_pilosa$variability_list)

# reverse the expenses
heatmap_data <- heatmap_data %>%
  mutate(
    MeanValue = ifelse(Outcome == "ParkExpenditure", -MeanValue, MeanValue)
  )

```

Plot a heatmap 

```{r plot_bubble_heatmap}
source("functions/plot_bubble_heatmap.R")
plot_bubble_heatmap(heatmap_data, title = "Bubble Plot for Bidens pilosa")
```

Plot an aggregated plot

```{r aggregated plot}
# Function to aggregate effects and variability across species
aggregate_species_data <- function(species_files) {
  aggregated_data <- data.frame()
  
  for (species_name in names(species_files)) {
    source(species_files[[species_name]])  # Load effects_sd_map for the species
    effects_sd_map <- get(paste0("effects_sd_map_", species_name))
    
    for (outcome in names(effects_sd_map)) {
      for (decision in names(effects_sd_map[[outcome]])) {
        effect <- effects_sd_map[[outcome]][[decision]]$Effect
        sd <- effects_sd_map[[outcome]][[decision]]$SD
        
        aggregated_data <- rbind(
          aggregated_data,
          data.frame(
            Species = species_name,
            Outcome = outcome,
            Decision = decision,
            Effect = effect,
            SD = sd
          )
        )
      }
    }
  }
  
  return(aggregated_data)
}

# Aggregate data across all species
aggregated_data <- aggregate_species_data(species_files)

# Summarize aggregated data
summary_data <- aggregated_data %>%
  group_by(Decision, Outcome) %>%
  summarize(
    MeanEffect = mean(Effect, na.rm = TRUE),
    MeanSD = mean(SD, na.rm = TRUE),
    .groups = "drop"
  )


library(ggplot2)

# Function to plot aggregate effects
plot_aggregate_effects <- function(data, title = "Aggregate Effects Across Species") {
  ggplot(data, aes(x = Decision, y = Outcome, size = 1 / MeanSD, fill = MeanEffect)) +
    geom_point(shape = 21, color = "black", alpha = 0.7) +
    scale_fill_gradient2(low = "red", mid = "white", high = "green", midpoint = 0) +
    scale_size_continuous(name = "Confidence (1/SD)", range = c(2, 10)) +
    labs(
      title = title,
      x = "Decision Options",
      y = "Outcomes",
      fill = "Mean Effect"
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      legend.position = "right"
    )
}

# Plot the data
plot_aggregate_effects(summary_data)

```

# Working with data from Bavi

The data is in Vietnamese so we translate it to English. 

```{r }
data <- read.csv("data/data.csv")

# translate names(data)

data_names <- c(
  "Family.plant", "Scientific.name", "Scientific.name.Yen.Hoai.edit",
  "Local.name", "Common.name", "Local.name...Dao.language.", "Habitat",
  "Lifeform", "Uses.To.cure.what.", "Value", "Parts used", "Usage", "Frequency
  of use" , "Number of users" , "Current reserves" , "Harvest sources" ,
  "Cultivation techniques" , "Market supply potential" , "Discovery of
  processed dishes" , "Nutritional value"
)


# Convert to snake_case (replace spaces and dots with underscores, make lowercase)
cleaned_names <- gsub("[ .]+", "_", tolower(data_names))
# Assign cleaned column names directly to the data frame
names(data) <- cleaned_names
```

### Extract relevant information from the data

Look for all the words to be translated with `unique(data$current_reserves)`. Add them to the dictionary `translation_dict` in `translate.R`

```{r define_dictionary}
# Source dictionary
source("functions/translate.R")
# function to translate the column
source("functions/translate_column.R")
```

If a species is rare (`current_reserves` is low), `SpeciesConservation` might get better with more restrictions. 

```{r translate_current_reserves}
 translate_column(data$current_reserves, translation_dict2)
```

If `parts_used` are roots, stems or whole plants then we can translate this as `destructive` and all other uses as `non_destructive`. The former type of use is more likely to have a negative `SpeciesConservation` effect with more access allowed.  

```{r translate_parts_used}
translate_column(data$parts_used, translation_dict3)
```

If `nutritional_value` is high then the effects on `DietaryDiversity` will be higher

```{r translate_nutritional_value}
translate_column(data$nutritional_value, translation_dict2)
```

If a species is important (`number_of_users` is high) `TraditionalKnowledge` might suffer under `control_access`

```{r translate_number_of_users}
translate_column(data$number_of_users, translation_dict2)
```

