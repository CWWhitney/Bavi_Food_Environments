## Create `bayesian_update_function`

Create a function for Bayesian updating with `purrr`, `fs` and `stringr`

```{r bayesian_update_function}
source("functions/bayesian_update.R")
```

Define directories

```{r define_directories}
# Define directories
species_dir <- "data"
updated_dir <- "data/updated"

# Ensure updated directory exists
dir_create("data/updated")
```

Also assign a base directory for the updated data

```{r name_base_directory}
# Ensure base directory
base_dir <- "data/updated"
```

List all the files that are in the `base_dir` in the new `updated_species_files`

```{r updated_species_files}
# Get all updated files
updated_species_files <- list.files(base_dir, pattern = "\\.R$", full.names = TRUE)
```

## Get all `unique_species` 

Trim away trailing and leading spaces with `trimws`

```{r unique_species}
# Get all unique species
unique_species <- unique(trimws(data$scientific_name_snake_case))  # Trim spaces
```

## Create `process_species` 

```{r process_species}

# Function to process each species
process_species <- function(species_name) {
  
  # Construct file paths
  species_filename <- str_c("effects_sd_map_", species_name, ".R")
  species_filepath <- file.path(species_dir, species_filename)
  updated_filename <- species_filename  # Keep the same filename
  updated_filepath <- file.path(updated_dir, updated_filename)
  
  # Check if file exists
  if (!file.exists(species_filepath)) {
    message("File not found for: ", species_name)
    return(NULL)
  }
  
  message("Sourcing R script: ", species_filepath)
  
  # Source the R script to load the effect data
  source(species_filepath, local = TRUE)
  
  # Identify the loaded variable dynamically
  loaded_objects <- ls(pattern = "effects_sd_map_")
  
  if (length(loaded_objects) == 0) {
    message("No object found in: ", species_filename)
    return(NULL)
  }
  
  # Extract the loaded object dynamically
  effects_data <- get(loaded_objects[1])
  
  # Define prior knowledge-based tweaks
  rare_species <- any(data$scientific_name_snake_case == species_name & data$current_reserves %in% c("Few", "Not many"))
  common_species <- any(data$scientific_name_snake_case == species_name & data$current_reserves == "Many")
  destructive_harvest <- any(data$scientific_name_snake_case == species_name & data$parts_used == "destructive")
  high_nutrition <- any(data$scientific_name_snake_case == species_name & data$nutritional_value == "High")
  low_nutrition <- any(data$scientific_name_snake_case == species_name & data$nutritional_value == "Low")
  high_number_of_users <- any(data$scientific_name_snake_case == species_name & data$number_of_users == "Many")
  few_users <- any(data$scientific_name_snake_case == species_name & data$number_of_users == "Few")
  
  # Adjust SpeciesConservation & SustainableFoodEnv for rare/common species
  if (rare_species) {
    effects_data$SpeciesConservation$control_access$Effect <- effects_data$SpeciesConservation$control_access$Effect + 0.05
    effects_data$SpeciesConservation$control_access$SD <- max(0.001, effects_data$SpeciesConservation$control_access$SD - 0.005)
    effects_data$SpeciesConservation$provide_seedlings$Effect <- effects_data$SpeciesConservation$provide_seedlings$Effect + 0.1
    effects_data$SpeciesConservation$provide_seedlings$SD <- max(0.001, effects_data$SpeciesConservation$provide_seedlings$SD - 0.005)
  }
  
  if (common_species) {
    effects_data$SpeciesConservation$control_access$Effect <- effects_data$SpeciesConservation$control_access$Effect - 0.05
    effects_data$SpeciesConservation$control_access$SD <- min(0.1, effects_data$SpeciesConservation$control_access$SD + 0.005)
    effects_data$SpeciesConservation$provide_seedlings$Effect <- effects_data$SpeciesConservation$provide_seedlings$Effect - 0.1
    effects_data$SpeciesConservation$provide_seedlings$SD <- min(0.1, effects_data$SpeciesConservation$provide_seedlings$SD + 0.005)
  }
  
  # Adjust for destructive harvesting
  if (destructive_harvest) {
    affected_parameters <- c("control_access", "provide_access_control_harvest",
                             "allow_access_forest_parts", "allow_access_limited_time")
    new_info <- list(effect_shift = -0.05, sd_shift = +0.005)
    
    effects_data$SpeciesConservation[affected_parameters] <- map(
      effects_data$SpeciesConservation[affected_parameters],
      ~ {
        prior_mean <- .x$Effect
        prior_sd <- .x$SD
        updated_values <- bayesian_update(
          prior_mean, prior_sd,
          prior_mean + new_info$effect_shift,
          max(0.001, prior_sd + new_info$sd_shift)
        )
        list(Effect = updated_values$mean, SD = updated_values$sd)
      }
    )
  }
  
  # Adjust for high/low nutrition
  if (high_nutrition) {
    effects_data$DietaryDiversity <- map(effects_data$DietaryDiversity, ~{
      list(Effect = .x$Effect + 0.05, SD = max(0.001, .x$SD - 0.005))
    })
  }
  
  if (low_nutrition) {
    effects_data$DietaryDiversity <- map(effects_data$DietaryDiversity, ~{
      list(Effect = .x$Effect - 0.05, SD = min(0.1, .x$SD + 0.005))
    })
  }
  
  # Adjust for high/few users
  if (high_number_of_users) {
    effects_data$TraditionalKnowledge$control_access$Effect <- effects_data$TraditionalKnowledge$control_access$Effect - 0.05
    effects_data$TraditionalKnowledge$control_access$SD <- max(0.001, effects_data$TraditionalKnowledge$control_access$SD - 0.005)
  }
  
  if (few_users) {
    effects_data$DietaryDiversity <- map(effects_data$DietaryDiversity, ~{
      list(Effect = .x$Effect - 0.05, SD = min(0.1, .x$SD + 0.005))
    })
  }
  
  # Save updated data as an R script
  dump(loaded_objects[1], file = updated_filepath)
  
  message("Updated and saved: ", updated_filename)
}

```

```{r create_species_names_for_updated_species_files}
# Extract species names by removing prefix and suffix
species_names <- sub("data/updated/effects_sd_map_(.*)\\.R", "\\1", updated_species_files)

```
Convert `species_names` to a named list

```{r updated_species_files_named}
# Convert to a named list
updated_species_files_named <- setNames(updated_species_files, species_names)

```

Use `walk` function from `purrr` to apply unique species names and `process_species` to all species in the data. 

```{r walk_unique_species_process_species}

# Apply function to all species
walk(names(updated_species_files_named), process_species)

```

### Plot an aggregated plot with `aggregate_species_data`

Plot generate aggregated data for all species in `updated_species_files_named` with `aggregate_species_data`

```{r aggregate_species_data_updated}
### Plot an aggregated plot with `aggregate_species_data`

source("functions/aggregate_species_data.R")
# Aggregate data across all species
aggregated_data <- aggregate_species_data(updated_species_files_named)

# Summarize aggregated data
summary_data <- aggregated_data %>%
  group_by(Decision, Outcome) %>%
  summarize(
    MeanEffect = mean(Effect, na.rm = TRUE),
    MeanSD = mean(SD, na.rm = TRUE),
    .groups = "drop"
  )

```

Apply `plot_aggregate_effects` to show the updated expectations across all the species in the study. 

```{r plot_aggregate_effects_update}
library(ggplot2)
source("functions/plot_aggregate_effects.R")
# Plot the data
plot_aggregate_effects(summary_data)

```
