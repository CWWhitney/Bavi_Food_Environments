

```{r }
library(ggplot2)
library(reshape2)
library(tidyverse)

effects_sd_map_bidens_pilosa <- source("data/effects_sd_map_bidens_pilosa.R")
# Observed data
data <- read.csv("data/observation_data_bavi.csv")
```

# Working with data from Bavi

The data is in Vietnamese so we translate it to English. 

```{r }
data <- read.csv("data/observation_data_bavi.csv")

# translate names(data)

data_names <- c(
  "Family.plant", "Scientific.name", "Scientific.name.Yen.Hoai.edit",
  "Local.name", "Common.name", "Local.name...Dao.language.", "Habitat",
  "Lifeform", "Uses.To.cure.what.", "Value", "Parts used", "Usage", "Frequency
  of use" , "Number of users" , "Current reserves" , "Harvest sources" ,
  "Cultivation techniques" , "Market supply potential" , "Discovery of
  processed dishes" , "Nutritional value"
)


# Convert to snake_case (replace spaces and dots with underscores, make lowercase)
cleaned_names <- gsub("[ .]+", "_", tolower(data_names))
# Assign cleaned column names directly to the data frame
names(data) <- cleaned_names
```

### Extract relevant information from the data

Look for all the words to be translated with `unique(data$current_reserves)`. Add them to the dictionary in `dictionaries.R` and translate with `translate_column`.

```{r define_dictionary}
# Source dictionary
source("functions/dictionaries.R")
# function to translate the column
source("functions/translate_column.R")
```

If `current_reserves` is `Few` or `Not many` (species is rare) we can expect positive `SpeciesConservation` effects with more restrictions. `control_access` and `provide_seedlings` will have a higher effect with lower SD, all the other options will likely be reduced. The effect would be similar for `SustainableFoodEnv`. `DietaryDiversity` would not be likely to change much. `ParkExpenditure` might also go up with more control. `TraditionalKnowledge` would likely not change much  since it is already a rare plant. If `current_reserves` are `Many` then the effects will be the opposite. 

```{r translate_current_reserves}
 translate_column(data$current_reserves, translation_dict2)
```

## Updating with parts_used data

If `parts_used` are roots, stems or whole plants then we can translate this as `destructive` and all other uses as `non_destructive`. The former type of use is more likely to have a negative `SpeciesConservation` effect with more access allowed and will shift the result.  

```{r translate_parts_used}
translate_column(data$parts_used, translation_dict3)
  # destructive_harvest <- any(data$scientific_name_snake_case == species_name & data$parts_used == "destructive")
```

If `nutritional_value` is high then the effects on `DietaryDiversity` will be raised. If `Low` effects on `DietaryDiversity` will be lowered. 

```{r translate_nutritional_value}
translate_column(data$nutritional_value, translation_dict2)

```

If `number_of_users` is `Many` then `TraditionalKnowledge` Effect would be lower and SD would be narrower for `control_access`. If it is `Few` then `DietaryDiversity` effects will be lower. 

```{r translate_number_of_users}
translate_column(data$number_of_users, translation_dict2)

```


```{r }
normalize_scientific_names <- function(data) {
  # Ensure scientific_name is a character vector
  data$scientific_name <- as.character(data$scientific_name)
  
  # Function to clean and convert to snake_case
  clean_name <- function(name) {
    name <- trimws(name)  # Remove leading/trailing spaces
    name <- tolower(name)  # Convert to lowercase
    name <- gsub("[ .]+", "_", name)  # Replace spaces and dots with underscores
    return(name)
  }
  
  # Apply function to all names
  data$scientific_name_snake_case <- sapply(data$scientific_name, clean_name, USE.NAMES = FALSE)
  
  return(data)
}

data <- normalize_scientific_names(data)  # Normalize names

```


```{r }
update_effects <- function(effects_sd_map, data_path, species_name = "bidens_pilosa",
                                    effect_multiplier = 1.5, sd_multiplier = 0.5) {
  # Load observation data
  data <- read.csv(data_path, stringsAsFactors = FALSE)
  
  # Check if the species is used destructively
  destructive_harvest <- any(data$scientific_name_snake_case == species_name & data$parts_used == "destructive")
  # high_nutrition <- any(data$scientific_name_snake_case == species_name & data$nutritional_value == "High") # If `nutritional_value` is high then the effect_multiplier on `DietaryDiversity` will be raised. 
  # high_nutrition <- any(data$scientific_name_snake_case == species_name & data$nutritional_value == "Low") # If `nutritional_value` is `Low` effect_multiplier on `DietaryDiversity` will be lowered and sd_multiplier will increase. 
  # high_number_of_users <- any(data$scientific_name_snake_case == species_name & data$number_of_users == "Many") # If `number_of_users` is `Many` then `TraditionalKnowledge` effect_multiplier would be lower and sd_multiplier would be narrower for `control_access`. 
  # few_users <- any(data$scientific_name_snake_case == species_name & data$number_of_users == "Few") # `number_of_users` is `Few` then `DietaryDiversity` effect_multiplier will be lower.   
  

  # Apply Bayesian update if species is destructively harvested
  if (destructive_harvest) {
    for (outcome in names(effects_sd_map)) {  # Loop over all outcomes
      for (decision in names(effects_sd_map[[outcome]])) {  # Loop over all decision options
        effects_sd_map[[outcome]][[decision]]$Effect <- 
          effects_sd_map[[outcome]][[decision]]$Effect * effect_multiplier
        
        effects_sd_map[[outcome]][[decision]]$SD <- 
          effects_sd_map[[outcome]][[decision]]$SD * sd_multiplier
      }
    }
  }
  
  return(effects_sd_map)
}
```

# Bayesian Updating

Use `Normal-Gaussian conjugate updating` for means and standard deviations.
Here we use `tidyverse` `dplyr` and `purrr` for clean data transformations.
The `Effects` and `SDs` are adjusted based on species-specific conditions. The `update_effects_bayesian` function assumes the prior effect is normally distributed. It incorporates new information (condition-based adjustments) using a weighted update. `map()` from `purrr` updates all the expected effects from the observations in four ways: 

- `parts_used` are roots or whole plants is a destructive harvest, which increases effect size and decreases uncertainty .
- High/Low Nutrition: Modifies effect and SD accordingly.
- User Count Impact: Adjusts effect size and uncertainty.
- This Bayesian approach dynamically integrates observed data into effect estimation while preserving uncertainty, ensuring a structured update.

```{r }
library(dplyr)
library(tidyr)
library(purrr)

update_effects_bayesian <- function(effects_sd_map,  species_name,
                                    effect_multiplier = .3, sd_multiplier = .1, 
                                    prior_sd = 0.1, observed_weight = 0.5) {
  # Load observation data
  data <- data
  
  # Check conditions based on the observed data
  destructive_harvest <- any(data$scientific_name_snake_case == species_name & data$parts_used == "destructive")
  high_nutrition <- any(data$scientific_name_snake_case == species_name & data$nutritional_value == "High")
  low_nutrition <- any(data$scientific_name_snake_case == species_name & data$nutritional_value == "Low")
  high_number_of_users <- any(data$scientific_name_snake_case == species_name & data$number_of_users == "Many")
  few_users <- any(data$scientific_name_snake_case == species_name & data$number_of_users == "Few")
  
  # Function for Bayesian updating (Gaussian Normal prior)
  bayesian_update <- function(prior_mean, prior_sd, new_data_mean, new_data_sd, weight) {
    posterior_mean <- (prior_mean / prior_sd^2 + new_data_mean / new_data_sd^2) / 
                      (1 / prior_sd^2 + 1 / new_data_sd^2)
    posterior_sd <- sqrt(1 / (1 / prior_sd^2 + 1 / new_data_sd^2)) * weight
    return(list(mean = posterior_mean, sd = posterior_sd))
  }
  
  # Apply updates based on conditions
  if (destructive_harvest || high_nutrition || low_nutrition || high_number_of_users || few_users) {
    effects_sd_map <- map(effects_sd_map, function(outcome_map) {
      map(outcome_map, function(decision_map) {
        # Extract prior values
        prior_effect <- decision_map$Effect
        prior_sd <- decision_map$SD
        
        # Adjust effect based on conditions
        observed_effect <- prior_effect
        observed_sd <- prior_sd
        
        if (destructive_harvest) {
          observed_effect <- observed_effect * effect_multiplier
          observed_sd <- observed_sd * sd_multiplier
        }
        if (high_nutrition) {
          observed_effect <- observed_effect * 1.2  # Boost effect slightly
        }
        if (low_nutrition) {
          observed_effect <- observed_effect * 0.8
          observed_sd <- observed_sd * 1.2
        }
        if (high_number_of_users) {
          observed_effect <- observed_effect * 0.9
          observed_sd <- observed_sd * 0.8
        }
        if (few_users) {
          observed_effect <- observed_effect * 0.7
        }
        
        # Apply Bayesian update
        updated_values <- bayesian_update(prior_effect, prior_sd, observed_effect, observed_sd, observed_weight)
        
        decision_map$Effect <- updated_values$mean
        decision_map$SD <- updated_values$sd
        
        return(decision_map)
      })
    })
  }
  
  return(effects_sd_map)
}

```

```{r }
effect_multiplier = 0.3 
sd_multiplier = 0.1
# Apply Bayesian updates based on observed data
effects_updated <- update_effects_bayesian(effects_sd_map_bidens_pilosa, species_name =  "bidens_pilosa")

```

```{r }
flatten_effects_to_df <- function(effects_sd_map) {
  results <- list()  

  # Ensure we access the actual values (skip the "value" wrapper)
  if ("value" %in% names(effects_sd_map)) {
    effects_sd_map <- effects_sd_map$value
  }

  for (outcome in names(effects_sd_map)) {
    for (decision in names(effects_sd_map[[outcome]])) {
      
      # Debugging: Check if the structure is correct
      print(paste("Processing:", outcome, "->", decision))
      print(str(effects_sd_map[[outcome]][[decision]]))  

      # Ensure effect values exist before adding
      if (is.list(effects_sd_map[[outcome]][[decision]]) &&
          !is.null(effects_sd_map[[outcome]][[decision]]$Effect) &&
          !is.null(effects_sd_map[[outcome]][[decision]]$SD)) {
        
        results[[length(results) + 1]] <- list(
          Decision = decision,
          Outcome = outcome,
          MeanValue = as.numeric(effects_sd_map[[outcome]][[decision]]$Effect),
          SD = as.numeric(effects_sd_map[[outcome]][[decision]]$SD)
        )
      } else {
        print(paste("Skipping invalid entry:", outcome, decision))
      }
    }
  }

  # Convert list to data frame
  if (length(results) > 0) {
    results_df <- do.call(rbind, lapply(results, as.data.frame))
    return(results_df)
  } else {
    warning("No valid data found in effects_sd_map.")
    return(data.frame(Decision=character(), Outcome=character(), MeanValue=numeric(), SD=numeric()))
  }
}


```

```{r }
effects_df <- flatten_effects_to_df(effects_updated)

effects_df$Decision <- as.character(effects_df$Decision)
effects_df$Outcome <- as.character(effects_df$Outcome)
```

```{r }
plot_bubble_heatmap <- function(heatmap_data, title = "Updated Decision Outcomes") {
  library(ggplot2)
  
  ggplot(heatmap_data, aes(x = Decision, y = Outcome, size = 1 / SD, fill = MeanValue)) +
    geom_point(shape = 21, color = "black", alpha = 0.7) +
    scale_fill_gradient2(low = "red", mid = "white", high = "green", midpoint = 0) +
    scale_size_continuous(name = "Confidence (1/SD)", range = c(2, 10)) +
    labs(
      title = title,
      x = "Decision Options",
      y = "Outcomes",
      fill = "Mean Effect"
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      legend.position = "right"
    )
}
```

```{r }
plot_bubble_heatmap(effects_df)
```
